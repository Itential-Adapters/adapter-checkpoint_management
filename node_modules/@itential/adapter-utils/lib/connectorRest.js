/* @copyright Itential, LLC 2018 */

// Set globals
/* global adapters brokers g_redis log */
/* eslint class-methods-use-this:warn */
/* eslint consistent-return:warn */
/* eslint import/no-dynamic-require:warn */
/* eslint no-underscore-dangle: [2, { "allow": ["_id"] }] */
/* eslint no-unused-vars:warn */
/* eslint no-use-before-define:warn */
/* eslint prefer-destructuring:warn */

/* NodeJS internal API utilities */
const uuid = require('uuid');
const os = require('os');
const fs = require('fs');

/* Fetch in the other needed components */
const path = require('path');
const https = require('https');
const http = require('http');
const socks5 = require('socks5-http-client');
const socks5s = require('socks5-https-client');
const AsyncLockCl = require('async-lock');

const ThrottleCl = require(path.join(__dirname, '/throttle.js'));

const allowFailover = 'AD.300';
const noFailover = 'AD.500';
let transUtilInst = null;
let propUtilInst = null;

// Global Variables - From Properties
let props = {};
let host = null;
let port = null;
let basepath = null;
let version = null;
let authMethod = null;
let authField = null;
let authFormat = null;
let username = null;
let password = null;
let staticToken = null;
let tokenUserField = 'username';
let tokenPwdField = 'password';
let tokenResField = 'token';
let tokenTimeout = -1;
let tokenError = 401;
let tokenPath = null;
let tokenCache = 'local';
const tokenList = [];
const tokenlock = 0;
let stub = false;
let protocol = 'http';
let healthcheckpath = null;
let throttleEnabled = false;
let ecdhAuto = false;
let sslEnabled = false;
let sslAcceptInvalid = false;
let sslCAFile = null;
let sslCiphers = null;
let secureProtocol = null;
let proxyEnabled = false;
let proxyHost = null;
let proxyPort = null;
let proxyProtocol = 'http';
let numRetries = 3;
let limitRetryError = 0;
let attemptTimeout = 5000;
let healthcheckOnTimeout = true;
let archiving = false;
let healthy = false;
const healthlock = 0;
let healthcheck = false;
const healthchecklock = 0;

// Other global variables
let id = null;
let phInstance = null;
let requestId = 0;
let archiveColl = '_results';
const NS_PER_SEC = 1e9;
let throttleEng = null;
let tlock = null;
let hlock = null;
let hclock = null;

let crest = null;
let cacheHHead = null;
let cacheHSchema = null;
let cacheHPay = null;

/* CONNECTOR ENGINE INTERNAL FUNCTIONS         */
/** Wait for adapter-mongo to be available.
 * @summary adapter may load before adapter-mongo but it requires
 * mongo to be available before. This function loops until mongo is available.
 */
function waitForMongo() {
  const origin = `${id}-connectorRest-waitForMongo`;
  log.trace(origin);

  return new Promise((resolve, reject) => {
    const INTERVAL = 5000;
    let count = 0;

    // Run this interval until we can connect to the Mongo Adapter
    const intervalObject = setInterval(() => {
      count += INTERVAL / 1000;

      // try to see if mongo is available
      return adapters.mongo.healthCheck((hc, error) => {
        if (hc) {
          if (hc.status === 'fail') {
            log.error(`${origin}: adapter-mongo reports a status = fail with error ${error}`);

            if (count === 100 * (INTERVAL / 1000)) {
              log.error(`${origin}: attempted mongo enough times - failing`);
              reject();
            }
          } else if (hc.status === 'success') {
            log.info(`${origin}: adapter-mongo reports a status = success. adapter will now attempt to connect.`);
            resolve();
            clearInterval(intervalObject);
          }
        }
        log.info(`${origin}: Waiting for adapter-mongo to be available. Seconds passed: ${count}.`);
      });
    }, INTERVAL);
  });
}

/** Wait for system to be available.
 * @summary assumes System has gone down and we are not able to connect
 *    to it and receive any data
 */
function waitForSystem() {
  const origin = `${id}-connectorRest-waitForSystem`;
  log.trace(origin);

  return new Promise((resolve, reject) => {
    // if not running healthchecks on timeout just return
    if (!healthcheckOnTimeout) {
      log.debug(`${origin}: skipping healthcheck after abort based on configuration`);
      resolve();
    }

    // Find out if currently healthy
    hlock.acquire(healthlock, (doneH) => {
      doneH(healthy);
    }, (retH) => {
      // healthy
      if (retH) {
        log.debug(`${origin}: skipping healthcheck since another command has executed successfully`);
        resolve();
      } else {
        // unhealthy
        let count = 0;

        // Run this interval until we can connect to the System
        const intervalObject = setInterval(() => {
          count += attemptTimeout / 1000;

          // Lock the healthcheck so only one healthcheck at a time
          hclock.acquire(healthchecklock, (doneHC) => {
            // if not already running
            if (!healthcheck) {
              healthcheck = true;
              doneHC(true);
            } else {
              doneHC(false);
            }
          }, (retHC) => {
            // need to run healthcheck
            if (retHC) {
              crest.healthCheck(cacheHSchema, cacheHPay, cacheHHead, (hc, error) => {
                if (hc) {
                  if (hc === 'fail') {
                    log.error(`${origin}: healthcheck reports a status = fail with error ${JSON.stringify(error)}`);

                    if (count === 100 * (attemptTimeout / 1000)) {
                      log.error(`${origin}: attempted healthcheck enough times - failing`);

                      // turn healthcheck false - since no longer active
                      hclock.acquire(healthchecklock, (doneHC2) => {
                        healthcheck = false;
                        doneHC2(true);
                      }, (retHC2) => {
                        reject();
                      });
                    }
                  } else if (hc === 'success') {
                    log.info(`${origin}: healthcheck reports a status = success. adapter will now restart processing.`);

                    // turn healthcheck false - since no longer active
                    hclock.acquire(healthchecklock, (doneHC3) => {
                      healthcheck = false;
                      doneHC3(true);
                    }, (retHC3) => {
                      resolve();
                      clearInterval(intervalObject);
                    });
                  }
                }

                log.info(`${origin}: Waiting for system to be available. Seconds passed: ${count}.`);
              });
            }
          });
        }, attemptTimeout);
      }
    });
  });
}

/*
 * INTERNAL FUNCTION: return stub results based on the path and method
 */
function returnStub(uriPath, method, type, entitySchema) {
  const origin = `${id}-connectorRest-returnStub`;
  log.trace(origin);

  const callResp = {
    status: 'success',
    code: 200,
    response: '{}'
  };

  // if there is no entity schema this should be a healthcheck
  if (!entitySchema) {
    log.error(`${origin}: healthcheck? no entity schema - no mock data to return`);
    return callResp;
  }

  log.trace(`${origin}: ${JSON.stringify(entitySchema)}`);

  // if there are no mock responses defined in the entity schema, stubbing will not work
  if (!Object.hasOwnProperty.call(entitySchema, 'mockresponses')) {
    callResp.status = 'failure';
    callResp.code = 400;
    callResp.message = 'no mock data defined in entity scheme - no mock data to return';
    delete callResp.response;

    log.error(`${origin}: ${callResp.message}`);
    return callResp;
  }

  const mockresponses = entitySchema.mockresponses;
  let specificResp = null;
  let specificFound = false;
  let defaultResp = null;
  let defaultFound = false;

  // Go through the mock data keys to find the proper data to return
  for (let p = 0; p < mockresponses.length; p += 1) {
    // is this the mock data for this call
    if (Object.hasOwnProperty.call(mockresponses[p], 'name')
        && uriPath === mockresponses[p].name) {
      if (Object.hasOwnProperty.call(mockresponses[p], 'method')
          && method === mockresponses[p].method.toUpperCase()) {
        if (Object.hasOwnProperty.call(mockresponses[p], 'type')
            && type === mockresponses[p].type.toUpperCase()) {
          // This is the mock data we really want as it best matches the request
          specificResp = {
            status: 'success',
            code: 200,
            response: {}
          };

          if (Object.hasOwnProperty.call(mockresponses[p], 'response')) {
            // if a status is defined in the response, use it
            if (Object.hasOwnProperty.call(mockresponses[p].response, 'response')
                && Object.hasOwnProperty.call(mockresponses[p].response, 'status')) {
              specificResp.code = mockresponses[p].response.status;
            }

            // if a response field is defined in the response, use it
            if (Object.hasOwnProperty.call(mockresponses[p].response, 'response')) {
              specificResp.response = JSON.stringify(mockresponses[p].response.response);
            } else {
              // if no response field, assume that the entire data is the response
              specificResp.response = JSON.stringify(mockresponses[p].response);
            }
          }

          specificFound = true;
          break;
        } else if (Object.hasOwnProperty.call(mockresponses[p], 'type')
            && mockresponses[p].type.toUpperCase() === 'DEFAULT') {
          // This is the default mock data in case we do not have a specific response defined
          defaultResp = {
            status: 'success',
            code: 200,
            response: {}
          };

          if (Object.hasOwnProperty.call(mockresponses[p], 'response')) {
            // if a status is defined in the response, use it
            if (Object.hasOwnProperty.call(mockresponses[p].response, 'response')
                && Object.hasOwnProperty.call(mockresponses[p].response, 'status')) {
              defaultResp.code = mockresponses[p].response.status;
            }

            // if a response field is defined in the response, use it
            if (Object.hasOwnProperty.call(mockresponses[p].response, 'response')) {
              defaultResp.response = JSON.stringify(mockresponses[p].response.response);
            } else {
              // if no response field, assume that the entire data is the response
              defaultResp.response = JSON.stringify(mockresponses[p].response);
            }
          }

          defaultFound = true;
        }
      }
    }
  }
  if (!specificFound && !defaultFound) {
    callResp.status = 'failure';
    callResp.code = 400;
    callResp.message = `no mock data for ${uriPath}-${type} - no mock data to return`;
    delete callResp.response;

    log.error(`${origin}: ${callResp.message}`);
    return callResp;
  }

  // if the specific response data was not found, use the default data
  if (!specificFound) {
    return defaultResp;
  }

  // return the sprcific response data
  return specificResp;
}

/*
 * INTERNAL FUNCTION: makeRequest makes the actual call to System
 */
function makeRequest(request, type, entitySchema, callback) {
  const origin = `${id}-connectorRest-makeRequest`;
  log.trace(origin);
  let myTimeout = attemptTimeout;

  // if there is a timeout from the action (schema) use it instead
  if (entitySchema && entitySchema.timeout) {
    myTimeout = entitySchema.timeout;
  }

  // if we need ecdhCurve set to auto
  if (ecdhAuto) {
    request.header.ecdhCurve = 'auto';
  }

  // STUB CODE - this is good for an initial test - set stub in Pronghorn property file to true
  if (stub) {
    return callback(returnStub(request.origPath, request.header.method.toUpperCase(), type.toUpperCase(), entitySchema));
  }

  try {
    let useProt = http;

    // determine proper protocol for primary request
    if ((proxyEnabled && proxyProtocol === 'https') || (!proxyEnabled && protocol === 'https')) {
      useProt = https;
    }
    if ((proxyEnabled && proxyProtocol === 'socks5' && protocol === 'http')) {
      useProt = socks5;
    }
    if ((proxyEnabled && proxyProtocol === 'socks5' && protocol === 'https')) {
      useProt = socks5s;
    }

    // make the call to System
    const httpRequest = useProt.request(request.header, (res) => {
      let respStr = '';
      res.setEncoding('utf8');

      // process data from response
      res.on('data', (replyData) => {
        respStr += replyData;
      });

      // process end of response
      res.on('end', () => {
        const callResp = {
          status: 'success',
          code: res.statusCode,
          response: respStr
        };

        // turn healthy true - since valid return
        hlock.acquire(healthlock, (doneH2) => {
          healthy = true;
          doneH2(true);
        }, (retH2) => {
          log.debug(`${origin}: CALL RETURN ${JSON.stringify(callResp)}`);
          useProt = undefined;
          return callback(callResp);
        });
      });
    });

    // handle post error
    httpRequest.on('error', (cerror) => {
      const callResp = {
        status: 'failure',
        code: 0,
        message: cerror
      };

      // turn healthy false - since error return
      hlock.acquire(healthlock, (doneH2) => {
        healthy = false;
        doneH2(true);
      }, (retH2) => {
        log.debug(`${origin}: ERROR RETURN ${JSON.stringify(callResp)}`);
        useProt = undefined;
        return callback(callResp);
      });
    });

    httpRequest.setTimeout(myTimeout, () => {
      httpRequest.abort();
    }, myTimeout);

    // write to the http request data to the body if not a get (gets do not have data in the body)
    if (request.header.method !== 'GET' && (request.body !== {} || entitySchema.sendEmpty)) {
      httpRequest.write(request.body);
    }

    // end the http request
    httpRequest.end();
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue during make request');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: finds the token in the object that was returned
 */
function findTokenInResult(result) {
  const origin = `${id}-connectorRest-findTokenInResult`;
  log.trace(origin);
  let token = null;

  if (!result) {
    return token;
  }

  // if the token is in this object
  if (result.token) {
    return result.token;
  }

  // need to check objects within this object
  const keys = Object.keys(result);

  for (let k = 0; k < keys; k += 1) {
    if (typeof result[k] === 'object') {
      const found = findTokenInResult(result[k]);

      // if we found the token
      if (found !== null) {
        token = result;
        break;
      }
    }
  }

  // return the found token
  return token;
}

/*
 * INTERNAL FUNCTION: finds the expiration in the object that was returned
 */
function findExpireInResult(result) {
  const origin = `${id}-connectorRest-findExpireInResult`;
  log.trace(origin);
  let expire = null;

  if (!result) {
    return expire;
  }

  // if the expires is in this object
  if (result.expires) {
    return new Date(result.expires).getTime();
  }

  // need to check objects within this object
  const keys = Object.keys(result);

  for (let k = 0; k < keys; k += 1) {
    if (typeof result[k] === 'object') {
      const found = findTokenInResult(result[k]);

      // if we found the expiration
      if (found !== null) {
        expire = new Date(result).getTime();
        break;
      }
    }
  }

  // return the found expiration
  return expire;
}

/*
 * INTERNAL FUNCTION: makes the request and processes the response
 * for the request to get the token
 */
function getToken(reqPath, options, tokenSchema, bodyString, callback) {
  const origin = `${id}-connectorRest-getToken`;
  log.trace(origin);

  try {
    // if there is a mock result, return that
    if (stub && tokenSchema) {
      // get the data from the mock data file
      const tokenResp =
        returnStub(tokenSchema.entitypath, options.method.toUpperCase(), 'DEFAULT', tokenSchema);

      // if the request failed, return the error
      if (tokenResp.code < 200 || tokenResp.code > 299) {
        const errorObj = transUtilInst.formatErrorObject(origin, 'Unable To Authenticate', ['Token', tokenResp.code], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }

      log.debug(tokenResp.response);

      // return the token from the token schema
      const translated =
        transUtilInst.mapFromOutboundEntity(tokenResp.response, tokenSchema.responseSchema);

      // if what we got back is an array, just return the first element
      // should only have one token!!!
      if (translated && Array.isArray(translated)) {
        return callback(translated[0]);
      }

      // return the token that we find in the translated object
      return callback(translated);
    }

    if (stub || reqPath === tokenPath || (tokenSchema && reqPath === tokenSchema.entitypath)) {
      // do not make the call to return a token if the request is actually
      // to get a token. Getting a token to get a token -- that should go
      // direct to make request
      return callback({ token: 'faketoken' });
    }

    log.debug(`${origin}: OPTIONS: ${JSON.stringify(options)}`);

    // no need for orig path since we handled the stub case
    const request = {
      header: options,
      body: bodyString,
      user: username,
      passwd: password
    };

    // request the token
    return makeRequest(request, 'DEFAULT', tokenSchema, (result, merror) => {
      if (merror) {
        return callback(null, merror);
      }

      // if the request failed, return the error
      if (result.code < 200 || result.code > 299) {
        const errorObj = transUtilInst.formatErrorObject(origin, 'Unable To Authenticate', ['Token', result.code], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }

      let currResult = JSON.parse(result.response);

      // parse the token out of the result
      if (!tokenSchema) {
        // if no token schema, return the token from the token field
        return callback(currResult);
      }

      // need to see if there is a response key
      if (tokenSchema.responseObjects) {
        let tKey = null;

        // it should be an array - then take the first element of array
        if (Array.isArray(tokenSchema.responseObjects)) {
          if (tokenSchema.responseObjects[0].key) {
            tKey = tokenSchema.responseObjects[0].key;
          }
        } else if (tokenSchema.responseObjects.key) {
          tKey = tokenSchema.responseObjects.key;
        }

        // if we found a key, use it
        if (tKey) {
          currResult = currResult[tKey];
        }
      }

      // the token should not be an array so if it is, return the 0 item.
      if (Array.isArray(currResult)) {
        currResult = currResult[0];
      }

      // return the token from the token schema
      const translated = transUtilInst.mapFromOutboundEntity(currResult, tokenSchema.responseSchema);

      // if what we got back is an array, just return the first element
      // should only have one token!!!
      if (translated && Array.isArray(translated)) {
        return callback(translated[0]);
      }

      // return the token that we find in the translated object
      return callback(translated);
    });
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue retrieving a token');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: prepares a request to get a token from the system
 */
function buildTokenRequest(reqPath, reqBody, callback) {
  const origin = `${id}-connectorRest-buildTokenRequest`;
  log.trace(origin);

  try {
    let tokenSchema = null;

    try {
      // Get the token schema from the file system
      tokenSchema = propUtilInst.getEntitySchema('.system', 'getToken');
      log.debug(`${origin}: Using action and schema for token information`);
    } catch (ex) {
      // Token schema is not required (could be defined in
      // properties so ignore the exception!!!
      log.debug(`${origin}: Using adapter properties for token information`);
    }

    // prepare the additional headers we received
    let thisAHdata = null;

    // see if there are headers from the action file
    if (tokenSchema && tokenSchema.headers) {
      thisAHdata = tokenSchema.headers;
    }

    // if no header data passed in create empty - will add data below
    if (!thisAHdata) {
      thisAHdata = {};
    } else {
      const hKeys = Object.keys(thisAHdata);

      for (let h = 0; h < hKeys.length; h += 1) {
        let tempStr = thisAHdata[hKeys[h]];

        // replace username variable
        if (tempStr.indexOf('{username}') >= 0) {
          tempStr = tempStr.replace('{username}', username);
        }
        // replace password variable
        if (tempStr.indexOf('{password}') >= 0) {
          tempStr = tempStr.replace('{password}', password);
        }
        thisAHdata[hKeys[h]] = tempStr;

        // handle any base64 encoding required on the authStr
        if (thisAHdata[hKeys[h]].indexOf('{b64}') >= 0) {
          // get the range to be encoded
          const sIndex = thisAHdata[hKeys[h]].indexOf('{b64}');
          const eIndex = thisAHdata[hKeys[h]].indexOf('{/b64}');

          // if start but no end - return an error
          if (sIndex >= 0 && eIndex < sIndex + 5) {
            const errorObj = transUtilInst.formatErrorObject(origin, 'Unable To Encode', [thisAHdata[hKeys[h]]], null, null, null);
            log.error(errorObj.IAPerror.displayString);
            return callback(null, errorObj);
          }

          // get the string to be encoded
          const bufString = thisAHdata[hKeys[h]].substring(sIndex + 5, eIndex);

          // encode the string
          const encString = Buffer.from(bufString).toString('base64');
          let tempAuthStr = '';

          // build the new auth field with the encoded string
          if (sIndex > 0) {
            // add the start of the string that did not need encoding
            tempAuthStr = thisAHdata[hKeys[h]].substring(0, sIndex);
          }
          // add the encoded string
          tempAuthStr += encString;
          if (eIndex + 5 < thisAHdata[hKeys[h]].length) {
            // add the end of the string that did not need encoding
            tempAuthStr += thisAHdata[hKeys[h]].substring(eIndex + 6);
          }

          // put the temp string into the auth string we will add to the request
          thisAHdata[hKeys[h]] = tempAuthStr;
        }
      }
    }

    // add the JSON headers if they were not set already
    if (!thisAHdata['Content-Type']) {
      thisAHdata['Content-Type'] = 'application/json';
    }
    if (!thisAHdata.Accept) {
      thisAHdata.Accept = 'application/json';
    }

    // set up the options for the call to get incidents - default is all
    const options = {
      hostname: host,
      port,
      path: tokenPath,
      method: 'POST',
      headers: thisAHdata
    };

    // If there is a token schema, need to take the data from there
    if (tokenSchema) {
      options.path = tokenSchema.entitypath;
      options.method = tokenSchema.method;
    }

    // if proxy enabled change the options accordingly
    if (proxyEnabled) {
      options.hostname = proxyHost;
      options.port = proxyPort;
      options.path = `${protocol}://${host}:${port}${options.path}`;
    }

    // if the path has a base path parameter in it, need to replace it
    const bpathStr = '{base_path}';
    if (options.path.indexOf(bpathStr) >= 0) {
      // replace with base path if we have one, otherwise remove base path
      if (basepath !== undefined && basepath !== null && basepath !== '') {
        options.path = options.path.replace(bpathStr, basepath);
      } else {
        options.path = options.path.replace(bpathStr, '');
      }
    }

    // if the path has a version parameter in it, need to replace it
    let versStr = '{version}';
    if (options.path.indexOf(versStr) >= 0) {
      // be able to support this if the version has a slash before it or not
      if (options.path.indexOf('/{version}') >= 0) {
        versStr = '/{version}';
      }

      // replace with version if we have one, otherwise remove version
      if (version !== undefined && version !== null && version !== '') {
        options.path = options.path.replace(versStr, `/${encodeURIComponent(version)}`);
      } else {
        options.path = options.path.replace(versStr, '');
      }
    }

    // if ssl enabled add the options for ssl
    if (sslEnabled) {
      if (sslAcceptInvalid) {
        // if we are accepting invalid certificates
        // (ok for lab not so much production)
        options.rejectUnauthorized = false;
      } else {
        // if we are not accepting invalid certs,
        // need the ca file in the options
        try {
          options.rejectUnauthorized = true;
          options.ca = [fs.readFileSync(sslCAFile)];
        } catch (e) {
          const errorObj = transUtilInst.formatErrorObject(origin, 'Missing File', [sslCAFile], null, null, null);
          log.error(errorObj.IAPerror.displayString);
          return callback(null, errorObj);
        }
      }

      if (sslCiphers) {
        options.ciphers = sslCiphers;
      }
      if (secureProtocol) {
        options.secureProtocol = secureProtocol;
      }

      log.info(`${origin}: Connector SSL connections enabled`);
    }

    const reqData = {};
    let bodyString = null;

    // if we have been passed a schema
    if (tokenSchema) {
      // if this is not a get, need to add the info to the request
      if (options.method !== 'GET') {
        const creds = {
          username,
          password
        };

        // if there is body data to add to the token request body
        if (reqBody) {
          const bodyKey = Object.keys(reqBody);

          for (let k = 0; k < bodyKey.length; k += 1) {
            creds[bodyKey[k]] = reqBody[bodyKey[k]];
          }
        }

        // map the data we received to an Entity - will get back the defaults
        const tokenEntity = transUtilInst.mapToOutboundEntity(creds, tokenSchema.requestSchema);
        bodyString = JSON.stringify(tokenEntity);

        // if there is a body, set the content length of the body and add it to
        // the header
        if (Object.keys(tokenEntity) > 0) {
          options.headers['Content-length'] = Buffer.byteLength(bodyString);
        }

        // request the token
        return getToken(reqPath, options, tokenSchema, bodyString, callback);
      }

      // if this is a get, need to put the username on the url
      if (options.path.indexOf('/{username}') >= 0) {
        options.path.replace('/{username}', username);
      } else {
        options.path.replace('{username}', username);
      }

      // if this is a get, need to put the password on the url
      if (options.path.indexOf('/{password}') >= 0) {
        options.path.replace('/{password}', password);
      } else {
        options.path.replace('{password}', password);
      }
    } else {
      // set the user and password for the token request
      reqData[tokenUserField] = username;
      reqData[tokenPwdField] = password;

      // since not a get call, convert reqData to a string and add length
      bodyString = JSON.stringify(reqData);
      options.headers['Content-length'] = Buffer.byteLength(bodyString);
    }

    // request the token
    return getToken(reqPath, options, tokenSchema, bodyString, callback);
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue requesting token');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: addTokenItem is used to add a token item to the
 *    memory based on the user provided
 */
function addTokenItem(user, token, timeout, callback) {
  const origin = `${id}-connectorRest-addTokenItem`;
  log.trace(origin);

  try {
    // there is already a lock from the get, so no need to lock the tokenList
    const now = new Date();

    // create the token item
    const tkey = `${id}__%%__${user}`;
    const tokenItem = {
      adapter: id,
      username: user,
      token,
      start: now.getTime(),
      expire: timeout
    };

    // add the token item to the tokenlist and return it
    if (tokenCache === 'local') {
      tokenList.push(tokenItem);
      return callback(token);
    }

    // try to add the token item to the redis local memory
    return g_redis.set(tkey, JSON.stringify(tokenItem), (err) => {
      if (err) {
        log.error(`${origin}: ${tkey} not stored in redis`);
      }

      // return the token
      return callback(token);
    });
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue adding token');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: retrieve the token from cache and determine if
 * it valid. if valid, return it otherwise return null
 */
function validToken(user, invalidToken, callback) {
  const origin = `${id}-connectorRest-validToken`;
  log.trace(origin);

  try {
    // time to see if the token is expired
    const expireCheck = new Date().getTime() + 60000;

    // determine where to get the token
    if (tokenCache === 'redis') {
      // get the token from redis
      const tkey = `${id}__%%__${user}`;
      return g_redis.get(tkey, (err, res) => {
        if (err) {
          log.error(`${origin}: Error on retrieve token for ${tkey}`);
        }

        // if there was no token returned
        if (!res) {
          return callback(null);
        }

        const parsedToken = JSON.parse(res);

        // if the token expired (or will expire within a minute),
        // or it is invalid (failed) remove it from the token list
        if (parsedToken.expire < expireCheck || parsedToken.token === invalidToken) {
          return g_redis.del(tkey, (derr) => {
            if (derr) {
              log.debug(`${origin}: Expired token for ${tkey} not removed from redis`);
            }

            return callback(null);
          });
        }

        // return the retrieved token
        return callback(parsedToken.token);
      });
    }

    let retToken = null;

    // find this user's token in the list
    for (let i = 0; i < tokenList.length; i += 1) {
      if (tokenList[i].username === user) {
        // if the token expired (or will expire within a minute),
        // or it is invalid (failed) remove it from the token list
        if (tokenList[i].expire < expireCheck
            || tokenList[i].token === invalidToken) {
          tokenList.splice(i, 1);
          break;
        }
        retToken = tokenList[i].token;
        break;
      }
    }
    return callback(retToken);
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue validating cached token');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: getTokenItem is used to retrieve a token items from
 *    memory based on the user provided
 */
function getTokenItem(pathForToken, user, reqBody, invalidToken, callback) {
  const origin = `${id}-connectorRest-getTokenItem`;
  log.trace(origin);

  try {
    // Lock the tokenList while getting the token
    return tlock.acquire(tokenlock, (done) => {
      validToken(user, invalidToken, (retToken, verror) => {
        if (verror) {
          done(null, verror);
        }

        // If valid token found, return it and skip the rest
        if (retToken !== null) {
          done(retToken, null);
        } else {
          // No valid token found, Need to get a new token and add it to the token list
          buildTokenRequest(pathForToken, reqBody, (dyntoken, berror) => {
            if (berror) {
              done(null, berror);
            }

            let timeout = tokenTimeout;

            // if we should use the timeout from the token request
            if (timeout === 0) {
              timeout = findExpireInResult(dyntoken);
            } else {
              // otherwise add the timeout to the current time
              timeout += new Date().getTime();
            }

            // if this is worth caching
            if (timeout && timeout > 0) {
              // since this is adding the token for future use, do not care when it comes back
              addTokenItem(username, findTokenInResult(dyntoken), timeout, (addedtoken, aerror) => {
                if (aerror) {
                  done(null, aerror);
                }
                done(findTokenInResult(dyntoken), null);
              });
            } else {
              done(findTokenInResult(dyntoken), null);
            }
          });
        }
      });
    }, (ret, error) => {
      if (error) {
        return callback(null, error);
      }

      return callback(ret);
    });
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue getting token item');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: addAuthToRequest determines the place to add the authentication
 * and adds the authentication string
 */
function addAuthToRequest(request, authStr, callback) {
  const origin = `${id}-connectorRest-addAuthToRequest`;
  log.trace(origin);

  try {
    let newAuthStr = authStr;

    // handle any base64 encoding required on the authStr
    if (authStr.indexOf('{b64}') >= 0) {
      // get the range to be encoded
      const sIndex = authStr.indexOf('{b64}');
      const eIndex = authStr.indexOf('{/b64}');

      // if start but no end - return an error
      if (sIndex >= 0 && eIndex < sIndex + 5) {
        const errorObj = transUtilInst.formatErrorObject(origin, 'Unable To Encode', [authStr], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }

      // get the string to be encoded
      const bufString = authStr.substring(sIndex + 5, eIndex);

      // encode the string
      const encString = Buffer.from(bufString).toString('base64');
      let tempAuthStr = '';

      // build the new auth field with the encoded string
      if (sIndex > 0) {
        // add the start of the string that did not need encoding
        tempAuthStr = authStr.substring(0, sIndex);
      }
      // add the encoded string
      tempAuthStr += encString;
      if (eIndex + 5 < authStr.length) {
        // add the end of the string that did not need encoding
        tempAuthStr += authStr.substring(eIndex + 6);
      }

      // put the temp string into the auth string we will add to the request
      newAuthStr = tempAuthStr;
    }

    // add the authentication field to the request
    const authPath = authField.split('.');
    let tempField = request;

    // get to the field in the object
    for (let a = 0; a < authPath.length; a += 1) {
      // if we are at the point to add the token
      if (a === authPath.length - 1) {
        tempField[authPath[a]] = newAuthStr;
      } else {
        // if the field is not defined in the request, add it
        if (tempField[authPath[a]] === undefined) {
          tempField[authPath[a]] = {};
        }

        // set the tempField to the next field in the path
        tempField = tempField[authPath[a]];
      }
    }

    // auth string is already in the request object
    return callback(newAuthStr);
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue adding authentication');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: requestAuthenticate determines the authentication for System,
 * and takes appropriate action to authenticate and then makes the request
 */
function requestAuthenticate(request, type, entitySchema, invalidToken, callback) {
  const origin = `${id}-connectorRest-requestAuthenticate`;
  log.trace(origin);

  try {
    if (authMethod === 'request_token') {
      // are we working with reusing tokens until they expire?
      if (tokenTimeout >= 0) {
        // get the token from the token list
        return getTokenItem(request.header.path, username, request.authData, invalidToken, (tres, terror) => {
          if (terror) {
            return callback(null, terror);
          }

          // if we got a valid token, use it
          if (tres !== null) {
            log.debug(`${origin}: ${tres} being used for user: ${username}`);

            // format the authentication string
            const authStr = authFormat.replace('{token}', tres);
            return addAuthToRequest(request, authStr, (authReq, aerror) => {
              if (aerror) {
                return callback(aerror);
              }

              request.tokenUsed = tres;

              // actually make the request now that the authentication has been added
              return makeRequest(request, type, entitySchema, callback);
            });
          }

          const errorObj = transUtilInst.formatErrorObject(origin, 'Unable To Get Token', [username], null, null, null);
          log.error(errorObj.IAPerror.displayString);
          return callback(null, errorObj);
        });
      }

      // if no token timeout then no token list - just get the token and continue
      return buildTokenRequest(request.header.path, request.authData, (dyntoken, berror) => {
        if (berror) {
          return callback(null, berror);
        }

        // format the authentication string
        const authStr = authFormat.replace('{token}', findTokenInResult(dyntoken));
        return addAuthToRequest(request, authStr, (authReq, aerror) => {
          if (aerror) {
            return callback(aerror);
          }

          // actually make the request now that the authentication has been added
          return makeRequest(request, type, entitySchema, callback);
        });
      });
    }

    if (authMethod === 'static_token') {
      // format the authentication string
      const authStr = authFormat.replace('{token}', staticToken);
      return addAuthToRequest(request, authStr, (authReq, aerror) => {
        if (aerror) {
          return callback(aerror);
        }

        // actually make the request now that the authentication has been added
        return makeRequest(request, type, entitySchema, callback);
      });
    }

    if (authMethod === 'basic user_password') {
      // format the authentication string
      let authStr = authFormat.replace('{username}', request.user);
      authStr = authStr.replace('{password}', request.passwd);
      return addAuthToRequest(request, authStr, (authReq, aerror) => {
        if (aerror) {
          return callback(aerror);
        }

        // actually make the request now that the authentication has been added
        return makeRequest(request, type, entitySchema, callback);
      });
    }
    // if no_authentication, there is no change to the request!

    // actual call to make the request
    return makeRequest(request, type, entitySchema, callback);
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue authentication');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: archiveResult is used to archive the results of the request along with
 *    the times that were taken at various steps in the process (wait, request and overall)
 */
function archiveResult(reqResult, callback) {
  const origin = `${id}-connectorRest-archiveResult`;
  log.trace(origin);

  try {
    if (!archiving) {
      return 'skipped';
    }

    // Add an Id to the result object that we are going to store in the database
    const data = reqResult;
    data._id = uuid.v4();

    // save the result object to the database
    return brokers.persistence.save(archiveColl, data._id, data, (result, error) => {
      if (error) {
        const errorObj = transUtilInst.formatErrorObject(origin, 'Unable To Save To Database', [error], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }

      return callback(result);
    });
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue archiving');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: handleEndResponse prepares the response to send back
 */
function handleEndResponse(request, makeResp, overallTime, callback) {
  const origin = `${id}-connectorRest-handleEndResponse`;
  log.trace(origin);

  try {
    const overallDiff = process.hrtime(overallTime);
    const overallEnd = (overallDiff[0] * NS_PER_SEC) + overallDiff[1];
    log.info(`${origin}: Request call to ${request.header.method} ${request.header.path}: Call took: ${overallEnd} nanoseconds`);

    const reqResult = {
      phInstance,
      request,
      overallEnd,
      response: makeResp
    };

    // archive the results
    try {
      archiveResult(reqResult, (archived, aerror) => {
        if (aerror) {
          log.spam(`Error Archived: ${JSON.stringify(aerror)}`);
        } else {
          log.spam(`Result Archived: ${JSON.stringify(archived)}`);
        }
      });
    } catch (ex) {
      log.spam('Swallowing the archive error');
    }

    // If the request was successful
    if (makeResp && makeResp.code && Number(makeResp.code) >= 200 && Number(makeResp.code) <= 299) {
      const newResp = {
        icode: `AD.${makeResp.code}`,
        response: makeResp.response
      };

      // return the response object
      return callback(newResp);
    }

    // if not successful - check to see if response or error
    if (makeResp) {
      const errorObj = transUtilInst.formatErrorObject(origin, 'Error On Request', [makeResp.code], makeResp.code, makeResp, null);
      log.error(errorObj.IAPerror.displayString);
      return callback(null, errorObj);
    }

    const errorObj = transUtilInst.formatErrorObject(origin, 'Error On Request', ['unknown'], null, null, null);
    log.error(errorObj.IAPerror.displayString);
    return callback(null, errorObj);
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue handling response');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: handleEndThrottleResponse prepares the response to send back
 *    specifically if throttling is turned on - to clean up the request in the queue
 */
function handleEndThrottleResponse(request, myTransTime, claimedLic, makeResp, reqTime, overallTime, waitEnd, callback) {
  const origin = `${id}-connectorRest-handleEndThrottleResponse`;
  log.trace(origin);

  try {
    const reqDiff = process.hrtime(reqTime);
    const overallDiff = process.hrtime(overallTime);
    const reqEnd = (reqDiff[0] * NS_PER_SEC) + reqDiff[1];
    const overallEnd = (overallDiff[0] * NS_PER_SEC) + overallDiff[1];
    log.info(`${origin}: Request ${claimedLic.request_id} Transaction ${myTransTime} call to ${request.header.method} ${request.header.path}: Call took ${reqEnd} - Overall Time: ${overallEnd} nanoseconds`);

    // finish the turn so the space can be freed
    return throttleEng.finishTurn(claimedLic, reqEnd, (fres, ferror) => {
      const reqResult = {
        phInstance,
        requestId: claimedLic.request_id,
        transNum: claimedLic.transNum,
        request,
        start: claimedLic.start,
        end: new Date().getTime(),
        waitEnd,
        reqEnd,
        overallEnd,
        response: makeResp
      };

      if (!ferror) {
        reqResult.end = fres.end;
      }

      // archive the results
      try {
        archiveResult(reqResult, (archived, aerror) => {
          if (aerror) {
            log.spam(`Error Archived: ${JSON.stringify(aerror)}`);
          } else {
            log.spam(`Result Archived: ${JSON.stringify(archived)}`);
          }
        });
      } catch (ex) {
        log.spam('Swallowing the archive error');
      }

      // If the request was successful
      if (makeResp !== null && makeResp.code !== undefined
          && Number(makeResp.code) >= 200 && Number(makeResp.code) <= 299) {
        const newResp = {
          icode: `AD.${makeResp.code}`,
          response: makeResp.response
        };

        // return the response object
        return callback(newResp);
      }

      // if not successful - check to see if response or error
      if (makeResp) {
        const errorObj = transUtilInst.formatErrorObject(origin, 'Error On Request', [makeResp.code], makeResp.code, makeResp, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }

      const errorObj = transUtilInst.formatErrorObject(origin, 'Error On Request', ['unknown'], null, null, null);
      log.error(errorObj.IAPerror.displayString);
      return callback(null, errorObj);
    });
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue handling response');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: re-attempt after an invalid response and figure out
 * how to handle the new response.
 */
function retryInvalidResponse(request, type, myTransTime, claimedLic, makeResp, reqTime, overallTime, waitEnd, numTries, entitySchema, callback) {
  const origin = `${id}-connectorRest-retryInvalidResponse`;
  log.trace(origin);

  try {
    // Need to get a new token and retry the request
    return requestAuthenticate(request, type, entitySchema, request.tokenUsed, (mres, merror) => {
      if (merror) {
        return callback(null, merror);
      }

      // if the response is valid - good data or legitimate data error
      if (mres !== null && mres.code !== undefined
          && Number(mres.code) !== Number(limitRetryError)
          && Number(mres.code) !== Number(tokenError)) {
        if (throttleEnabled) {
          return handleEndThrottleResponse(request, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, callback);
        }

        return handleEndResponse(request, mres, overallTime, callback);
      } else if (mres !== null && mres.code !== undefined
          && Number(mres.code) !== Number(tokenError)) {
        // if we took a invalid token error - System out of licenses - try again
        // stop trying if we have tried enough
        if (numTries > numRetries) {
          if (throttleEnabled) {
            return handleEndThrottleResponse(request, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, callback);
          }

          return handleEndResponse(request, mres, overallTime, callback);
        }

        // Keep trying to get a good response
        return handleInvalidToken(request, type, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, numTries + 1, entitySchema, callback);
      } else if (mres !== null && mres.code !== undefined
          && Number(mres.code) !== Number(limitRetryError)) {
        // if we took a throughput limitation - System out of licenses - try again
        // stop trying if we have tried enough
        if (numTries > numRetries) {
          if (throttleEnabled) {
            return handleEndThrottleResponse(request, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, callback);
          }

          return handleEndResponse(request, mres, overallTime, callback);
        }

        // Keep trying to get a good response
        return handleLimitResponse(request, type, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, numTries + 1, entitySchema, callback);
      } else if (numTries > numRetries) {
        // if we took an http error - like aborting
        // stop trying if we have tried enough
        if (throttleEnabled) {
          return handleEndThrottleResponse(request, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, callback);
        }

        return handleEndResponse(request, mres, overallTime, callback);
      }

      // Keep trying to get a good response
      return handleAbortResponse(request, type, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, numTries + 1, entitySchema, callback);
    });
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue retrying invalid');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: handleInvalidToken handles issues when a token has timed out
 */
function handleInvalidToken(request, type, myTransTime, claimedLic, makeResp, reqTime, overallTime, waitEnd, numTries, entitySchema, callback) {
  const origin = `${id}-connectorRest-handleInvalidToken`;
  log.trace(origin);
  let reqDiff = process.hrtime(reqTime);
  let reqEnd = (reqDiff[0] * NS_PER_SEC) + reqDiff[1];
  log.warn(`${origin}: Request ${claimedLic.request_id} Transaction ${myTransTime} invalid token appear to be hit after ${reqEnd} nanoseconds - Entering handling invalid token`);
  reqDiff = undefined;
  reqEnd = undefined;

  try {
    // Need to retry the request - will pull new token
    return retryInvalidResponse(request, type, myTransTime, claimedLic, makeResp, reqTime, overallTime, waitEnd, numTries, entitySchema, callback);
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue handling invalid token');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: handleLimitResponse handles throughput issues with System
 */
function handleLimitResponse(request, type, myTransTime, claimedLic, makeResp, reqTime, overallTime, waitEnd, numTries, entitySchema, callback) {
  const origin = `${id}-connectorRest-handleLimitResponse`;
  log.trace(origin);
  let reqDiff = process.hrtime(reqTime);
  let reqEnd = (reqDiff[0] * NS_PER_SEC) + reqDiff[1];
  log.warn(`${origin}: Request ${claimedLic.request_id} Transaction ${myTransTime} limits appear to be hit after ${reqEnd} nanoseconds - Entering handling limiting requests`);
  reqDiff = undefined;
  reqEnd = undefined;
  let myTimeout = attemptTimeout;

  // if there is a timeout from the action (schema) use it instead
  if (entitySchema && entitySchema.timeout) {
    myTimeout = entitySchema.timeout;
  }

  try {
    // Run this after an interval to see if throughput issues clear
    const timeoutObject = setTimeout(() => {
      log.debug(`${origin}: Processing Re-request`);

      // nothing to do but retry
      return retryInvalidResponse(request, type, myTransTime, claimedLic, makeResp, reqTime, overallTime, waitEnd, numTries, entitySchema, callback);
    }, myTimeout / 5);
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue handling limit');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: handleAbortResponse handles timeout issues with System
 *    like when the system has died
 */
function handleAbortResponse(request, type, myTransTime, claimedLic, makeResp, reqTime, overallTime, waitEnd, numTries, entitySchema, callback) {
  const origin = `${id}-connectorRest-handleAbortResponse`;
  log.trace(origin);
  let reqDiff = process.hrtime(reqTime);
  let reqEnd = (reqDiff[0] * NS_PER_SEC) + reqDiff[1];
  log.warn(`${origin}: Request ${claimedLic.request_id} Transaction ${myTransTime} aborted after ${reqEnd} nanoseconds - Entering handling aborted requests`);
  reqDiff = undefined;
  reqEnd = undefined;

  try {
    // wait for System to come back with a good healthcheck
    return waitForSystem()
      .then(() => {
        log.debug(`${origin}: Cleared to reattempt`);

        // restart the current request
        return retryInvalidResponse(request, type, myTransTime, claimedLic, makeResp, reqTime, overallTime, waitEnd, numTries, entitySchema, callback);
      });
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue handling abort');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: noQueueRequest is used to perform normal requests.
 *    Normal being request that can run as they come in - there are no license or
 *    throttling limitations on these requests.
 */
function noQueueRequest(request, type, overallTime, entitySchema, callback) {
  const origin = `${id}-connectorRest-noQueueRequest`;
  log.trace(origin);

  try {
    // call to make the request
    return requestAuthenticate(request, type, entitySchema, null, (mres, merror) => {
      if (merror) {
        return callback(null, merror);
      }

      // if the response is valid - good data or legitimate data error
      if (mres !== null && mres.code !== undefined
          && Number(mres.code) !== Number(limitRetryError)
          && Number(mres.code) !== Number(tokenError)) {
        return handleEndResponse(request, mres, overallTime, callback);
      }

      if (mres !== null && mres.code !== undefined
          && Number(mres.code) !== Number(tokenError)) {
        // if we took a out of licenses - try one more time
        return handleInvalidToken(request, type, 0, { request_id: 0 }, mres, overallTime, overallTime, 0, 1, entitySchema, callback);
      }

      if (mres !== null && mres.code !== undefined
          && Number(mres.code) !== Number(limitRetryError)) {
        // if we took a out of licenses - try one more time
        return handleLimitResponse(request, type, 0, { request_id: 0 }, mres, overallTime, overallTime, 0, 1, entitySchema, callback);
      }

      // if we took an http error - like aborting
      return handleAbortResponse(request, type, 0, { request_id: 0 }, mres, overallTime, overallTime, 0, 1, entitySchema, callback);
    });
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue with request');
    return callback(null, errorObj);
  }
}

/*
 * INTERNAL FUNCTION: makeThrottleRequest is used to perform throttled request.
 *    Throttled request means that Pronghorn is only allowed to run X concurrent
 *    requests to the system.
 *
 *    It will put the request in a queue item, wait until
 *    it can get its turn, then run the request and return the results
 */
function queueThrottleRequest(request, type, myRequestId, myTransTime, overallTime, entitySchema, callback) {
  const origin = `${id}-connectorRest-queueThrottleRequest`;
  log.trace(`${origin} - ${myRequestId}`);

  try {
    // request place in Queue
    return throttleEng.requestQueueItem(myRequestId, myTransTime, (myItem, qerror) => {
      if (qerror) {
        return callback(null, qerror);
      }

      let waitStart = process.hrtime();

      // check if it is my turn
      return throttleEng.waitingMyTurn(myItem, (claimedLic, werror) => {
        let waitDiff = process.hrtime(waitStart);
        const waitEnd = (waitDiff[0] * NS_PER_SEC) + waitDiff[1];
        log.debug(`${origin}: Request ${myRequestId} Transaction ${myTransTime} wait took: ${waitEnd} nanoseconds`);
        const reqTime = process.hrtime();

        if (werror) {
          return callback(null, werror);
        }

        // clean up used variables from memory setting to undefined minimizes memory
        waitStart = undefined;
        waitDiff = undefined;

        // call to make the request
        return requestAuthenticate(request, type, entitySchema, null, (mres, merror) => {
          if (merror) {
            return callback(null, merror);
          }

          // if the response is valid - good data or legitimate data error
          if (mres !== null && mres.code !== undefined
              && Number(mres.code) !== Number(limitRetryError)
              && Number(mres.code) !== Number(tokenError)) {
            return handleEndThrottleResponse(request, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, callback);
          }

          if (mres !== null && mres.code !== undefined
              && Number(mres.code) !== Number(tokenError)) {
            // if we took a out of licenses - try one more time
            return handleInvalidToken(request, type, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, 1, entitySchema, callback);
          }

          if (mres !== null && mres.code !== undefined
              && Number(mres.code) !== Number(limitRetryError)) {
            // if we took a out of licenses - try one more time
            return handleLimitResponse(request, type, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, 1, entitySchema, callback);
          }

          // if we took an http error - like aborting
          return handleAbortResponse(request, type, myTransTime, claimedLic, mres, reqTime, overallTime, waitEnd, 1, entitySchema, callback);
        });
      });
    });
  } catch (e) {
    // handle any exception
    const errorObj = transUtilInst.checkAndReturn(e, origin, 'Issue with queue request');
    return callback(null, errorObj);
  }
}


class ConnectorRest {
  /**
   * Connector
   * @constructor
   */
  constructor(prongid, properties, transUtilCl, propUtilCl) {
    this.myid = prongid;
    id = prongid;

    this.transUtil = transUtilCl;
    transUtilInst = this.transUtil;
    this.propUtil = propUtilCl;
    propUtilInst = this.propUtil;

    // this uniquely identifies this adapter on this pronghorn system
    phInstance = `${id}-${os.hostname()}`;
    archiveColl = id + archiveColl;
    this.tlockInst = new AsyncLockCl();
    tlock = this.tlockInst;
    this.hlockInst = new AsyncLockCl();
    hlock = this.hlockInst;
    this.hclockInst = new AsyncLockCl();
    hclock = this.hclockInst;
    this.slock = new AsyncLockCl();
    crest = this;

    // set up the properties I care about
    this.refreshProperties(properties);

    if (throttleEnabled) {
      this.throttleEngInst = new ThrottleCl(id, properties, this.transUtil);
      throttleEng = this.throttleEngInst;
    }

    this.connect((status) => {
      const origin = `${this.myid}-connectorRest-constructor`;
      log.info(`${origin}: connect status ${status}`);
    });
  }

  /* CONNECTOR ENGINE EXTERNAL FUNCTIONS         */
  /**
   * refreshProperties is used to set up all of the properties for the connector.
   * It allows properties to be changed later by simply calling refreshProperties rather
   * than having to restart the connector.
   *
   * @function refreshProperties
   * @param {Object} properties - an object containing all of the properties
   */
  refreshProperties(properties) {
    const origin = `${this.myid}-connectorRest-refreshProperties`;
    log.trace(origin);
    props = properties;

    if (!props) {
      log.error(`${origin}: Connector received no properties!`);
      return;
    }

    // REPLACE WITH SCHEMA VALIDATOR???
    // get all of my properties - use for initial connectivity check
    // set the host (required - default is null)
    if (typeof props.host === 'string') {
      host = props.host;
    }

    // set the port (required - default is null)
    if (typeof props.port === 'number' || typeof props.port === 'string') {
      port = Number(props.port);
    }

    // set the base path (optional - default is null)
    if (typeof props.base_path === 'string') {
      basepath = props.base_path;
    }

    // set the version (optional - default is null)
    if (typeof props.version === 'string') {
      version = props.version;
    }

    if (props.authentication) {
      // set the authentication method (required - default is null)
      if (typeof props.authentication.auth_method === 'string') {
        authMethod = props.authentication.auth_method;
      }

      // set the username (required - default is null)
      if (typeof props.authentication.username === 'string') {
        username = props.authentication.username;
      }

      // set the password (required - default is null)
      if (typeof props.authentication.password === 'string') {
        password = props.authentication.password;
      }

      // set the static token (required - default is null)
      if (typeof props.authentication.token === 'string') {
        staticToken = props.authentication.token;
      }

      // set the token user field (required - default is username)
      if (typeof props.authentication.token_user_field === 'string') {
        tokenUserField = props.authentication.token_user_field;
      }

      // set the token password field (required - default is password)
      if (typeof props.authentication.token_password_field === 'string') {
        tokenPwdField = props.authentication.token_password_field;
      }

      // set the token result field (required - default is token)
      if (typeof props.authentication.token_result_field === 'string') {
        tokenResField = props.authentication.token_result_field;
      }

      // set the token URI path (required - default is null)
      if (typeof props.authentication.token_URI_path === 'string') {
        tokenPath = props.authentication.token_URI_path;
      }

      // set the proxy port (optional - default is null)
      if (typeof props.authentication.invalid_token_error === 'number'
          || typeof props.authentication.invalid_token_error === 'string') {
        tokenError = Number(props.authentication.invalid_token_error);
      }

      // set the proxy port (optional - default is null)
      if (typeof props.authentication.token_timeout === 'number'
          || typeof props.authentication.token_timeout === 'string') {
        tokenTimeout = Number(props.authentication.token_timeout);
      }

      // set the token cache (required - default is local)
      if (typeof props.authentication.token_cache === 'string') {
        tokenCache = props.authentication.token_cache;
      }

      // set the auth field (required - default is null)
      if (typeof props.authentication.auth_field === 'string') {
        authField = props.authentication.auth_field;
      }

      // set the auth format (required - default is null)
      if (typeof props.authentication.auth_field_format === 'string') {
        authFormat = props.authentication.auth_field_format;
      }
    }

    // set the stub mode (optional - default is false)
    if (typeof props.stub === 'boolean') {
      stub = props.stub;
    }

    // set the protocol (optional - default is http)
    if (typeof props.protocol === 'string') {
      protocol = props.protocol;
    }

    // set the healthcheck path (required - default is null)
    if (props.healthcheck) {
      if (typeof props.healthcheck.URI_Path === 'string') {
        healthcheckpath = props.healthcheck.URI_Path;
      }
    }

    if (props.throttle) {
      // set the throttle enabled (optional - default is false)
      if (typeof props.throttle.throttle_enabled === 'boolean') {
        throttleEnabled = props.throttle.throttle_enabled;
      }
    }

    if (props.request) {
      // set the number of retries (optional - default is 3)
      if (typeof props.request.number_retries === 'number' ||
          typeof props.request.number_retries === 'string') {
        numRetries = Number(props.request.number_retries);
      }

      // set the request retry error (optional - default is 0)
      if (typeof props.request.limit_retry_error === 'number' ||
          typeof props.request.limit_retry_error === 'string') {
        limitRetryError = Number(props.request.limit_retry_error);
      }

      // set the request attempt timeout (optional - default is 5000)
      if (typeof props.request.attempt_timeout === 'number' ||
          typeof props.request.attempt_timeout === 'string') {
        attemptTimeout = Number(props.request.attempt_timeout);
      }

      // set the request archiving flag (optional - default is false)
      if (typeof props.request.healthcheck_on_timeout === 'boolean') {
        healthcheckOnTimeout = props.request.healthcheck_on_timeout;
      }

      // set the request archiving flag (optional - default is false)
      if (typeof props.request.archiving === 'boolean') {
        archiving = props.request.archiving;
      }
    }

    if (props.proxy) {
      // set the proxy enabled (optional - default is false)
      if (typeof props.proxy.enabled === 'boolean') {
        proxyEnabled = props.proxy.enabled;
      }

      // set the proxy host (optional - default is null)
      if (typeof props.proxy.host === 'string') {
        proxyHost = props.proxy.host;
      }

      // set the proxy port (optional - default is null)
      if (typeof props.proxy.port === 'number' || typeof props.proxy.port === 'string') {
        proxyPort = Number(props.proxy.port);
      }

      // set the proxy protocol (optional - default is same as protocol)
      if (typeof props.proxy.protocol === 'string') {
        proxyProtocol = props.proxy.protocol;
      } else {
        proxyProtocol = protocol;
      }
    }

    if (props.ssl) {
      // set the ssl enabled (optional - default is false)
      if (typeof props.ssl.enabled === 'boolean') {
        sslEnabled = props.ssl.enabled;
      }

      // set the ssl ecdhCurve (optional - default is false)
      if (typeof props.ssl.ecdhCurve === 'string' && props.ssl.ecdhCurve === 'auto') {
        ecdhAuto = true;
      }

      // set the ssl accept invalid cert (optional - default is false)
      if (typeof props.ssl.accept_invalid_cert === 'boolean') {
        sslAcceptInvalid = props.ssl.accept_invalid_cert;
      }

      // set the ssl ca file (optional - default is null)
      if (typeof props.ssl.ca_file === 'string') {
        sslCAFile = props.ssl.ca_file;
      }

      // set the ssl ciphers (optional - default is null)
      if (typeof props.ssl.ciphers === 'string') {
        sslCiphers = props.ssl.ciphers;
      }

      // set the ssl ciphers (optional - default is null)
      if (typeof props.ssl.secure_protocol === 'string') {
        secureProtocol = props.ssl.secure_protocol;
      }
    }

    // if this is truly a refresh and we hae a throttle engine, refresh it
    if (this.throttleEngInst) {
      this.throttleEngInst.refreshProperties(properties);
    }
  }

  /**
   * Connect function is used to verify that everything required to connect and communicate
   * has been provided.
   *
   * @function connect
   * @param {Function} callback - a callback function to return the result - connected?
   */
  connect(callback) {
    const origin = `${this.myid}-connectorRest-connect`;
    log.trace(origin);

    // if throttling or archiving, need to make sure the database is there
    if ((throttleEnabled) || archiving) {
      // CLEAN UP LOCK & LICENSES
      return waitForMongo()
        .then(() => {
          if (archiving) {
            // If result collection does not exist, create one
            brokers.persistence.search(archiveColl, {}, (data, error) => {
              if (error || !data || !data[0]) {
                log.info(`${origin}: Result collection does not exist, creating new collection`);
                const resultObject = {};

                // add the result to the database
                brokers.persistence.create(archiveColl, resultObject, (cdata, cerror) => {
                  if (cerror) {
                    log.error(`${origin}: Could not create Result ${cerror}`);
                  }
                });
              } else {
                log.info(`${origin}: Result collection check passed`);
              }
            });
          }

          if (throttleEnabled) {
            this.throttleEngInst.verifyReady((res, rerror) => {
              if (rerror) {
                return callback(false);
              }

              log.debug(`${origin}: Throttle verify - ${res}`);
            });
          }

          // Make sure all the properties are loaded
          if (host === null || host === undefined || host === '') {
            log.error(`${origin}: FAILED TO LOAD - missing host`);
            return callback(false);
          }
          if (port === null || port === undefined || port === '') {
            log.error(`${origin}: FAILED TO LOAD - missing port`);
            return callback(false);
          }
          if (authMethod === 'static_token') {
            if (staticToken === null || staticToken === undefined || staticToken === '') {
              log.error(`${origin}: FAILED TO LOAD - missing static token`);
              return callback(false);
            }
          } else if (authMethod === 'request_token' || authMethod === 'basic user_password') {
            if (username === null || username === undefined || username === '') {
              log.error(`${origin}: FAILED TO LOAD - missing username`);
              return callback(false);
            }
            if (password === null || password === undefined || password === '') {
              log.error(`${origin}: FAILED TO LOAD - missing password`);
              return callback(false);
            }
          }
          if (sslEnabled && !sslAcceptInvalid
              && (sslCAFile === null || sslCAFile === undefined || sslCAFile === '')) {
            log.error(`${origin}: FAILED TO LOAD - missing required CA File`);
            return callback(false);
          }

          return callback(true);
        });
    }

    // Make sure all the properties are loaded
    if (host === null || host === undefined || host === '') {
      log.error(`${origin}: FAILED TO LOAD - missing host`);
      return callback(false);
    }
    if (port === null || port === undefined || port === '') {
      log.error(`${origin}: FAILED TO LOAD - missing port`);
      return callback(false);
    }
    if (authMethod === 'static_token') {
      if (staticToken === null || staticToken === undefined || staticToken === '') {
        log.error(`${origin}: FAILED TO LOAD - missing static token`);
        return callback(false);
      }
    } else if (authMethod === 'request_token' || authMethod === 'basic user_password') {
      if (username === null || username === undefined || username === '') {
        log.error(`${origin}: FAILED TO LOAD - missing username`);
        return callback(false);
      }
      if (password === null || password === undefined || password === '') {
        log.error(`${origin}: FAILED TO LOAD - missing password`);
        return callback(false);
      }
    }
    if (sslEnabled && !sslAcceptInvalid
        && (sslCAFile === null || sslCAFile === undefined || sslCAFile === '')) {
      log.error(`${origin}: FAILED TO LOAD - missing required CA File`);
      return callback(false);
    }

    return callback(true);
  }

  /**
   * HealthCheck function is used to provide Pronghorn the status of this adapter.
   *
   * @function healthCheck
   * @param {Object} healthSchema - the schema for the healthcheck (optional)
   * @param {String} payload - the contents to send with the healthcheck
   *                           (optional)
   * @param {Object} headers - this allows for additional headers to
   *                           be added to the request. (optional)
   *                           Can be a stringified Object.
   * @param {Function} callback - a callback function to return the result of the healthcheck
   */
  healthCheck(healthSchema, payload, headers, callback) {
    const origin = `${this.myid}-connectorRest-healthCheck`;
    log.trace(origin);

    try {
      // healthcheck can not be throttled and put in queue because it would be blocked
      // so build the request for a simple call and make the request
      const options = {
        hostname: host,
        port,
        path: healthcheckpath,
        method: 'GET',
        headers
      };

      // save headers in memory
      if (headers) {
        // save it in memory
        cacheHHead = headers;
      }

      // if there is a healthcheck schema, over ride the properties
      if (healthSchema) {
        options.path = healthSchema.entitypath;
        options.method = healthSchema.method;

        // save it in memory
        cacheHSchema = healthSchema;
      }

      // if proxy enabled change the options accordingly
      if (proxyEnabled) {
        options.hostname = proxyHost;
        options.port = proxyPort;
        options.path = `${protocol}://${host}:${port}${options.path}`;
      }

      // if the path has a base path parameter in it, need to replace it
      const bpathStr = '{base_path}';
      if (options.path.indexOf(bpathStr) >= 0) {
        // replace with base path if we have one, otherwise remove base path
        if (basepath !== undefined && basepath !== null && basepath !== '') {
          options.path = options.path.replace(bpathStr, basepath);
        } else {
          options.path = options.path.replace(bpathStr, '');
        }
      }

      // if the path has a version parameter in it, need to replace it
      let versStr = '{version}';
      if (options.path.indexOf(versStr) >= 0) {
        // be able to support this if the version has a slash before it or not
        if (options.path.indexOf('/{version}') >= 0) {
          versStr = '/{version}';
        }

        // replace with version if we have one, otherwise remove version
        if (version !== undefined && version !== null && version !== '') {
          options.path = options.path.replace(versStr, `/${encodeURIComponent(version)}`);
        } else {
          options.path = options.path.replace(versStr, '');
        }
      }

      // if ssl enabled add the options for ssl
      if (sslEnabled) {
        if (sslAcceptInvalid) {
          // if we are accepting invalid certificates (ok for lab not so much production)
          options.rejectUnauthorized = false;
        } else {
          // if we are not accepting invalid certs, need the ca file in the options
          try {
            options.rejectUnauthorized = true;
            options.ca = [fs.readFileSync(sslCAFile)];
          } catch (e) {
            const errorObj = this.transUtil.formatErrorObject(origin, 'Missing File', [sslCAFile], null, null, null);
            log.error(errorObj.IAPerror.displayString);
            return callback(null, errorObj);
          }
        }

        if (sslCiphers) {
          options.ciphers = sslCiphers;
        }
        if (secureProtocol) {
          options.secureProtocol = secureProtocol;
        }

        log.info(`${origin}: Connector SSL connections enabled`);
      }

      log.debug(`${origin}: HEALTHCHECK OPTIONS: ${JSON.stringify(options)}`);

      if (payload !== undefined && payload !== null && payload !== '') {
        log.debug(`${origin}: REQUEST: ${payload}`);

        // save it in memory
        cacheHPay = payload;
      }

      const request = {
        header: options,
        body: payload,
        user: username,
        passwd: password
      };

      // if there is a healthcheck schema, over ride the properties
      if (healthSchema !== null) {
        request.origPath = healthSchema.entitypath;
      }

      // call to make the request
      return requestAuthenticate(request, 'DEFAULT', healthSchema, null, (pres, perror) => {
        if (perror) {
          return callback(null, perror);
        }

        if (pres !== null && pres.code !== undefined
            && (Number(pres.code) < 200 || Number(pres.code) > 299)) {
          const errorObj = this.transUtil.formatErrorObject(origin, 'Error On Request', [pres.code], pres.code, pres, null);
          log.error(errorObj.IAPerror.displayString);
          return callback(null, errorObj);
        }
        const returnObj = {
          code: 'AD.200'
        };

        returnObj.response = pres;
        return callback(returnObj);
      });
    } catch (e) {
      // handle any exception
      const errorObj = this.transUtil.checkAndReturn(e, origin, 'Issue with healthcheck');
      return callback(null, errorObj);
    }
  }

  /**
   * Generic request handler for System requests. Will take in the incoming request which includes
   * a path, a method and an optional user and password. This information will be used to set up
   * the correct request to the system.  It will then process the request and return the results.
   *
   * @function performRequest
   * @param {Object} incoming - the information for the request. Must have a path and a method.
   *                            Can optionally have user and passwd (required)
   * @param {String} entitySchema - the entity schema (required)
   * @param {Function} callback - a callback function to return the result of the request
   */
  performRequest(incoming, entitySchema, callback) {
    const origin = `${this.myid}-connectorRest-performRequest`;
    log.trace(origin);
    const overallTime = process.hrtime();

    try {
      // verify data was received
      if (incoming === null) {
        const errorObj = this.transUtil.formatErrorObject(origin, 'Missing Data', ['request'], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }
      if (incoming.path === undefined || incoming.path === null || incoming.path === '') {
        const errorObj = this.transUtil.formatErrorObject(origin, 'Missing Data', ['request path'], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }
      if (incoming.method === undefined || incoming.method === null || incoming.method === '') {
        const errorObj = this.transUtil.formatErrorObject(origin, 'Missing Data', ['request method'], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }

      // set up the type of request - default, withid, withoptions, withquery
      let type = 'DEFAULT';

      if (incoming.respType !== undefined && incoming.respType !== null) {
        type = incoming.respType;
      }

      // set up the right credentials - passed in overrides default
      let loginUser = username;
      let loginPass = password;

      if (incoming.user !== undefined && incoming.user !== null && incoming.user !== '') {
        loginUser = incoming.user;
      }
      if (incoming.passwd !== undefined && incoming.passwd !== null && incoming.passwd !== '') {
        loginPass = incoming.passwd;
      }

      // set up the options for the call
      let options = {
        hostname: host,
        port,
        path: incoming.path,
        method: incoming.method,
        headers: incoming.addlHeaders
      };

      // if proxy enabled change the options accordingly
      if (proxyEnabled) {
        options.hostname = proxyHost;
        options.port = proxyPort;
        options.path = `${protocol}://${host}:${port}${incoming.path}`;
      }

      // if ssl enabled add the options for ssl
      if (sslEnabled) {
        if (sslAcceptInvalid) {
          // if we are accepting invalid certificates (ok for lab not so much production)
          options.rejectUnauthorized = false;
        } else {
          // if we are not accepting invalid certs, need the ca file in the options
          try {
            options.rejectUnauthorized = true;
            options.ca = [fs.readFileSync(sslCAFile)];
          } catch (e) {
            const errorObj = this.transUtil.formatErrorObject(origin, 'Missing File', [sslCAFile], null, null, null);
            log.error(errorObj.IAPerror.displayString);
            return callback(null, errorObj);
          }
        }

        if (sslCiphers) {
          options.ciphers = sslCiphers;
        }
        if (secureProtocol) {
          options.secureProtocol = secureProtocol;
        }

        log.info(`${origin}: Connector SSL connections enabled`);
      }

      log.debug(`${origin}: OPTIONS: ${JSON.stringify(options)}`);

      if (incoming.body !== undefined && incoming.body !== null && incoming.body !== '') {
        log.debug(`${origin}:REQUEST: ${incoming.body}`);
      }

      const request = {
        header: options,
        body: incoming.body,
        user: loginUser,
        passwd: loginPass,
        origPath: incoming.origPath
      };

      // if there is additional authentication data, add it to the request
      if (incoming.authData) {
        request.authData = incoming.authData;
      }

      // clean up used variables from memory setting to undefined minimizes memory
      options = undefined;

      if (!throttleEnabled) {
        return noQueueRequest(request, type, overallTime, entitySchema, callback);
      }

      let myRequest = requestId;
      let myTransTime = new Date().getTime();

      // Lock the global to increment it and reset the local
      return this.slock.acquire(requestId, (done) => {
        requestId += 1;
        myRequest = requestId;
        myTransTime = new Date().getTime();
        done(true);
      }, (ret) => {
        if (ret) {
          return queueThrottleRequest(request, type, myRequest, myTransTime, overallTime, entitySchema, callback);
        }

        return queueThrottleRequest(request, type, myRequest, myTransTime, overallTime, entitySchema, callback);
      });
    } catch (e) {
      // handle any exception
      const errorObj = this.transUtil.checkAndReturn(e, origin, 'Issue performing the request');
      return callback(null, errorObj);
    }
  }

  /**
   * getQueue is used to get information for all of the requests currently in the queue.
   *
   * @function getQueue
   * @param {Function} callback - a callback function to return the queue
   */
  getQueue(callback) {
    const origin = `${this.myid}-connectorRest-getQueue`;
    log.trace(origin);

    try {
      if (!throttleEnabled) {
        log.error(`${origin}: Throttling not enabled, no queue`);
        return [];
      }

      return throttleEng.getQueue(callback);
    } catch (e) {
      // handle any exception
      const errorObj = this.transUtil.checkAndReturn(e, origin, 'Issue getting queue');
      return callback(null, errorObj);
    }
  }
}

module.exports = ConnectorRest;
