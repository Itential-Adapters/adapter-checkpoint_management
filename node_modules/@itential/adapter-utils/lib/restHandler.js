/* @copyright Itential, LLC 2018 */

// Set globals
/* global log */

/* NodeJS internal utilities */
const querystring = require('querystring');

let transUtilInst = null;
let connectorInst = null;

// Other global variables
let id = null;
let versionGl = null;
let basepathGl = null;


// INTERNAL FUNCTIONS
/**
 * INTERNAL FUNCTION
 *
 * @summary Standard rest entity(ies) extracted as it it would be redundant code.
 *
 * @function handleRestRequest
 * @param {Object} request - the request to make (required)
 * @param {String} entityId - the id of the entity we are retrieving (optional)
 * @param {String} entitySchema - the entity schema (required)
 * @param {Function} callback - a callback function to return the result of the request
 */
function handleRestRequest(request, entityId, entitySchema, callback) {
  const origin = `${id}-restHandler-handleRestRequest`;
  log.trace(origin);

  try {
    // perform the request to get entity(ies)
    return connectorInst.performRequest(request, entitySchema, (resObj, perror) => {
      if (perror) {
        let retError = null;
        const retErrorObj = perror;

        // set the normal headers based on the type of data for the call
        if (entitySchema && entitySchema.datatype && entitySchema.datatype.toUpperCase() === 'PLAIN') {
          // return the error response
          return callback(null, retErrorObj);
        }
        if (entitySchema && entitySchema.datatype && entitySchema.datatype.toUpperCase() === 'XML') {
          // return the error response
          return callback(null, retErrorObj);
        }

        // process the error response - parse it if possible
        if (perror.raw_response) {
          try {
            retError = JSON.parse(perror.raw_response);
          } catch (ex) {
            // otherwise log parse failure but still return the unparsed error
            log.error(`An error occurred parsing the error JSON: ${ex}`);
          }
        }

        // if the return error message was JSON then return the parsed object
        if (retError !== null) {
          retErrorObj.response = retError;
        }

        // return the error response
        return callback(null, retErrorObj);
      }

      let respObjKey = '';
      let respKeyFound = false;
      let defaultObjKey = '';

      if (entitySchema.responseObjects) {
        const responseKeys = entitySchema.responseObjects;
        let type = 'DEFAULT';

        if (request.respType) {
          type = request.respType.toUpperCase();
        }

        // Go through the response keys to find the proper one
        for (let p = 0; p < responseKeys.length; p += 1) {
          // is this the response for this call
          if (responseKeys[p].name && request.origPath === responseKeys[p].name) {
            if (responseKeys[p].method
                && request.method.toUpperCase() === responseKeys[p].method.toUpperCase()) {
              if (responseKeys[p].type
                  && type === responseKeys[p].type.toUpperCase()) {
                // This is the Key we really want as it best matches the request
                if (responseKeys[p].key) {
                  respObjKey = responseKeys[p].key;
                }
                respKeyFound = true;
                break;
              } else if (responseKeys[p].type
                  && responseKeys[p].type.toUpperCase() === 'DEFAULT') {
                // This is the default key in case we do not have a specific
                // response defined
                if (responseKeys[p].key) {
                  defaultObjKey = responseKeys[p].key;
                }
              }
            }
          }
        }
      }

      // if the specific response key was not found, use the default key
      if (!respKeyFound) {
        respObjKey = defaultObjKey;
      }

      let retResponse = resObj.response;
      const retObject = resObj;

      // if id, log response (if all - too much to log all)
      if (entityId === 'nomap') {
        log.debug(`${origin}: RESPONSE: ${resObj.response}`);

        // if no mapping (do not care about response just that we did not
        // error) set response
        retObject.response = 'success';
        return callback(retObject);
      }

      // set the normal headers based on the type of data for the call
      if (entitySchema && entitySchema.datatype && entitySchema.datatype.toUpperCase() === 'PLAIN') {
        log.debug(`${origin}: RESPONSE: ${resObj.response}`);

        // return the response
        return callback(retObject);
      }
      if (entitySchema && entitySchema.datatype && entitySchema.datatype.toUpperCase() === 'XML') {
        log.debug(`${origin}: RESPONSE: ${resObj.response}`);

        // return the response
        return callback(retObject);
      }

      // process the response - parse it
      if (resObj.response !== null && resObj.response !== '') {
        try {
          retResponse = JSON.parse(resObj.response);
        } catch (ex) {
          // otherwise log parse failure and return the unparsed response
          log.warn(`${origin}: An error occurred parsing the resulting JSON: ${ex}`);
          return callback(retObject);
        }
      }

      if (respObjKey !== '') {
        // if the response is an array, log the first item
        if (retResponse[respObjKey].constructor === Array) {
          log.debug(`${origin}: RESPONSE (FIRST): ${JSON.stringify(retResponse[respObjKey][0])}`);
        } else {
          log.debug(`${origin}: RESPONSE: ${JSON.stringify(retResponse[respObjKey])}`);
        }
      } else if (retResponse.constructor === Array) {
        // if the response is an array, log the first item
        log.debug(`${origin}: RESPONSE (FIRST): ${JSON.stringify(retResponse[0])}`);
      } else {
        log.debug(`${origin}: RESPONSE: ${JSON.stringify(retResponse)}`);
      }

      // Make the call to translate the received Entity to Pronghorn Entity
      if (respObjKey !== '') {
        // added the translated response to the return Object
        retObject.response = transUtilInst.mapFromOutboundEntity(retResponse[respObjKey], entitySchema.responseSchema);
        return callback(retObject);
      }

      // added the translated response to the return Object
      retObject.response = transUtilInst.mapFromOutboundEntity(retResponse, entitySchema.responseSchema);
      return callback(retObject);
    });
  } catch (e) {
    // create the error object
    const errorObj = {
      origin,
      type: 'Caught Exception',
      vars: [],
      exception: e
    };

    log.error(`${origin}: Caught Exception: ${e}`);
    return callback(null, errorObj);
  }
}

/**
 * @summary Build the path for the request
 *
 * @function buildRequestPath
 * @param {String} entity - the name of the entity action is on. (required)
 * @param {String} action - the name of the action being executed. (required)
 * @param {Object} entitySchema - the entity schema for the entity and action. (required)
 * @param {String} reqPath - the entitypath from the entity action (required)
 * @param {Array} uriPathVars - the array of path variables (optional)
 * @param {Object} uriQuery - the object containing the query to add to the url (optional)
 * @param {Object} uriOptions - the object containing the options to add to the url (optional)
 */
function buildRequestPath(entity, action, entitySchema, reqPath, uriPathVars, uriQuery, uriOptions) {
  const origin = `${id}-restHandler-buildRequestPath`;
  log.trace(origin);

  // create the generic part of an error object
  const errorObj = {
    origin
  };

  try {
    let uriPath = reqPath;
    let respType = 'default';

    // if the path has a base path parameter in it, need to replace it
    const bpathStr = '{base_path}';
    if (uriPath.indexOf(bpathStr) >= 0) {
      // replace with base path if we have one, otherwise remove base path
      if (basepathGl) {
        uriPath = uriPath.replace(bpathStr, basepathGl);
      } else {
        uriPath = uriPath.replace(bpathStr, '');
      }
    }

    // if the path has a version parameter in it, need to replace it
    let versStr = '{version}';
    if (uriPath.indexOf(versStr) >= 0) {
      // be able to support this if the version has a slash before it or not
      if (uriPath.indexOf('/{version}') >= 0) {
        versStr = '/{version}';
      }

      // replace with version if we have one, otherwise remove version
      if (versionGl) {
        uriPath = uriPath.replace(versStr, `/${encodeURIComponent(versionGl)}`);
      } else {
        uriPath = uriPath.replace(versStr, '');
      }
    }

    // if there are URI path variables that have been provided, need to add
    // them to the path
    if (uriPathVars && uriPathVars.length > 0) {
      for (let p = 0; p < uriPathVars.length; p += 1) {
        const vnum = p + 1;
        const holder = `pathv${vnum.toString()}`;
        const hindex = uriPath.indexOf(holder);

        // if path variable is in the url, replace it!!!
        if (hindex >= 0 && uriPathVars[p] !== null && uriPathVars[p] !== '') {
          // with the provided id
          let idString = '';

          // check if the current URI path ends with a slash (may require
          // slash at end)
          if (uriPath[hindex - 2] === '/') {
            // ends with a slash need to add slash to end
            idString = encodeURIComponent(uriPathVars[p]);
          } else {
            // otherwise add / to start
            idString = '/';
            idString += encodeURIComponent(uriPathVars[p]);
          }

          // replace the id in url with the id string
          uriPath = uriPath.replace(`{${holder}}`, idString);

          // set the response type to with id so we know the response
          // and can find the key and mockdata
          respType = `with${holder}`;
        }
      }
    }

    // need to remove all of the remaining path holders from the URI
    while (uriPath.indexOf('{pathv') >= 0) {
      let sIndex = uriPath.indexOf('{pathv');
      const eIndex = uriPath.indexOf('}', sIndex);

      // if there is a / before the {pathv} need to remove it
      if (uriPath[sIndex - 1] === '/') {
        sIndex -= 1;
      }

      if (sIndex > 0) {
        // add the start of the path
        let tempStr = uriPath.substring(0, sIndex);

        if (eIndex < uriPath.length) {
          // add the end of the path
          tempStr += uriPath.substring(eIndex + 1);
        }

        uriPath = tempStr;
      } else if (eIndex > 0 && eIndex < uriPath.length) {
        // add the end of the path
        uriPath = uriPath.substring(eIndex + 1);
      } else {
        // should not get here - there is some issue in the uripath - missing
        // an end or the path is just {pathv#}
        // add the specific pieces of the error object
        errorObj.type = 'Invalid Action File';
        errorObj.vars = ['missing entity path', `${entity}/${action}`];

        // log and throw the error
        log.error(`${origin}: Path is required for ${entity}-${action}`);
        throw new Error(JSON.stringify(errorObj));
      }
    }

    // prepare the uri options we received
    const thisOdata = transUtilInst.formatInputData(uriOptions);
    let optionString = '';

    // need to format the option string
    if (thisOdata !== null) {
      optionString += querystring.stringify(thisOdata);
    }

    // prepare the query parameters we received
    const thisQdata = transUtilInst.formatInputData(uriQuery);

    // if this is a get with query parameters, need to make them part of
    // the request
    if (uriPath.indexOf('{query}') >= 0 && thisQdata !== null) {
      // request type set for determining required fields
      thisQdata.ph_request_type = action;

      // map the data we received for query
      const systemQuery = transUtilInst.mapToOutboundEntity(thisQdata, entitySchema.requestSchema);

      if (!systemQuery) {
        // should not get here - there is some issue in the uripath - missing
        // an end or the path is just {pathv#}
        // add the specific pieces of the error object
        errorObj.type = 'Query Not Translated';
        errorObj.vars = [];

        // log and throw the error
        log.error(`${origin}: Query not translated`);
        throw new Error(JSON.stringify(errorObj));
      }

      let addquery = '';

      // make sure we still have queries (that what was in the query is
      // legit)
      if (Object.keys(systemQuery).length > 0) {
        // need to format the option string
        if (entitySchema.querykey) {
          addquery = entitySchema.querykey;
        }
        if (systemQuery !== null) {
          addquery += querystring.stringify(systemQuery);
        }

        // set the response type to with query so we know the response
        // and can find the key and mockdata - id overrides options
        if (respType.indexOf('withpath') < 0) {
          respType = 'withquery';
        }
      }

      // if there is a query key in the path and the query
      if (addquery.indexOf('?') >= 0 && uriPath.indexOf('?') >= 0) {
        // need to remove one of them
        const squery = uriPath.indexOf('?');
        let equery = uriPath.indexOf('{query}');
        equery += 7;
        let tempPath = uriPath.substring(0, squery);
        tempPath += addquery;

        if (equery < uriPath.length) {
          tempPath += uriPath(equery + 7);
        }

        uriPath = tempPath;
      } else {
        // if not, just replace the query
        uriPath = uriPath.replace('{query}', addquery);
      }

      // if there are options, add them to the URL
      if (optionString !== '') {
        uriPath += `&${optionString}`;
      }

      const result = {
        path: uriPath,
        type: respType
      };

      return result;
    }

    // if there is a query key in the path
    if (uriPath.indexOf('?') >= 0) {
      // need to remove the key as well
      const squery = uriPath.indexOf('?');
      let equery = uriPath.indexOf('{query}');
      equery += 7;
      let tempPath = uriPath.substring(0, squery);

      if (equery < uriPath.length) {
        tempPath += uriPath(equery);
      }

      uriPath = tempPath;
    } else if (uriPath.indexOf('{query}') >= 0) {
      // if not, just replace the query
      uriPath = uriPath.replace('{query}', '');
    }

    // if there are options, add them to the URL
    if (optionString !== '') {
      uriPath += `?${optionString}`;
    }

    const result = {
      path: uriPath,
      type: respType
    };

    return result;
  } catch (e) {
    return transUtilInst.checkAndThrow(e, origin, 'Issue building request path');
  }
}

/**
 * @summary Method to merge the headers for the request
 *
 * @function mergeHeaders
 * @param {Object} addlHeaders - the headers from the request (optional)
 * @param {Object} entitySchema - the entity schema for the entity and action. (optional)
 *
 * @return {Object} - the merged headers
 */
function mergeHeaders(addlHeaders, entitySchema) {
  const origin = `${id}-restHandler-mergeHeaders`;
  log.trace(origin);

  // prepare the additional headers we received
  let thisAHdata = transUtilInst.formatInputData(addlHeaders);

  // merge the headers - priority is incoming over actionfile
  if (entitySchema.headers && thisAHdata) {
    const thisAHKeys = Object.keys(thisAHdata);
    const actHKeys = Object.keys(entitySchema.headers);

    // go through the headers in the action file
    for (let a = 0; a < actHKeys; a += 1) {
      let found = false;

      // go through the headers that came in
      for (let h = 0; h < thisAHKeys.length; h += 1) {
        // if the keys match, we will not add the header
        if (actHKeys[a] === thisAHKeys[h]) {
          found = true;
        }
      }

      // if the header was not found, add it
      if (!found) {
        thisAHdata[actHKeys[a]] = entitySchema.headers[actHKeys[a]];
      }
    }
  } else if (entitySchema.headers) {
    thisAHdata = entitySchema.headers;
  }

  // if no header data passed in create empty
  if (!thisAHdata) {
    thisAHdata = {};
  }

  // set the normal headers based on the type of data for the call
  if (entitySchema && entitySchema.datatype && entitySchema.datatype.toUpperCase() === 'PLAIN') {
    // add the Plain headers if they were not set already
    if (!thisAHdata['Content-Type']) {
      thisAHdata['Content-Type'] = 'text/plain';
    }
    if (!thisAHdata.Accept) {
      thisAHdata.Accept = 'text/plain';
    }
  } else if (entitySchema && entitySchema.datatype && entitySchema.datatype.toUpperCase() === 'XML') {
    // add the XML headers if they were not set already
    if (!thisAHdata['Content-Type']) {
      thisAHdata['Content-Type'] = 'application/xml';
    }
    if (!thisAHdata.Accept) {
      thisAHdata.Accept = 'application/xml';
    }
  } else {
    // add the JSON headers if they were not set already
    if (!thisAHdata['Content-Type']) {
      thisAHdata['Content-Type'] = 'application/json';
    }
    if (!thisAHdata.Accept) {
      thisAHdata.Accept = 'application/json';
    }
  }

  return thisAHdata;
}

/**
 * @summary Build the payload for the request
 *
 * @function buildPayload
 * @param {String} entity - the name of the entity action is on. (required)
 * @param {String} action - the name of the action being executed. (required)
 * @param {Object} entitySchema - the entity schema for the entity and action. (required)
 * @param {Object} requestObj - an object that contains the payload prior to translation
 *                              (optional). Can be a stringified Object.
 * @param {String} datatype - the type of data being sent and received (optional)
 */
function buildPayload(entity, action, entitySchema, payload) {
  const origin = `${id}-restHandler-buildPayload`;
  log.trace(origin);

  try {
    // prepare the body parameters we received
    let thisBdata = transUtilInst.formatInputData(payload);

    // return the payload if just sending plain text and got plain text
    if (entitySchema && entitySchema.datatype && entitySchema.datatype.toUpperCase() === 'PLAIN') {
      if (!thisBdata) {
        thisBdata = '';
      }
      if (typeof thisBdata !== 'object') {
        return thisBdata;
      }
    }
    // return the payload if just sending xml and got xml (as string)
    if (entitySchema && entitySchema.datatype && entitySchema.datatype.toUpperCase() === 'XML') {
      if (!thisBdata) {
        thisBdata = '';
      }
      if (typeof thisBdata !== 'object') {
        return thisBdata;
      }
    }

    // handle input as JSON
    if (!thisBdata) {
      thisBdata = {};
    }

    // request type set for determining required fields
    thisBdata.ph_request_type = action;

    // map the data we received to a [System] Entity
    const systemEntity = transUtilInst.mapToOutboundEntity(thisBdata, entitySchema.requestSchema);

    if (!systemEntity) {
      // create the error object
      const errorObj = {
        origin,
        type: 'Payload Not Translated',
        vars: []
      };

      // log and throw the error
      log.error(`${origin}: Payload not translated`);
      throw new Error(JSON.stringify(errorObj));
    }

    // return the payload
    return JSON.stringify(systemEntity);
  } catch (e) {
    return transUtilInst.checkAndThrow(e, origin, 'Issue building payload');
  }
}


class RestHandler {
  /**
   * Rest Entity
   * @constructor
   */
  constructor(prongId, properties, connectorCl, transUtilCl) {
    id = prongId;
    this.myid = prongId;

    // reference to the needed classes for class methods
    this.connector = connectorCl;
    connectorInst = this.connector;
    this.transUtil = transUtilCl;
    transUtilInst = this.transUtil;

    // set up the properties I care about
    this.refreshProperties(properties);
  }

  /**
   * refreshProperties is used to set up all of the properties for the rest handler.
   * It allows properties to be changed later by simply calling refreshProperties rather
   * than having to restart the rest handler.
   *
   * @function refreshProperties
   * @param {Object} properties - an object containing all of the properties
   */
  refreshProperties(properties) {
    const origin = `${this.myid}-restHandler-refreshProperties`;
    log.trace(origin);

    if (!properties) {
      log.error(`${origin}: Rest Handler received no properties!`);
      return;
    }

    this.version = properties.version;
    versionGl = this.version;
    this.basepath = properties.base_path;
    basepathGl = this.basepath;
  }

  /**
   * @summary Formats and makes the REST call
   *
   * @function genericRestRequest
   * @param {String} entity - the name of the entity for this request.
   *                          (required)
   * @param {String} action - the name of the action being executed. (required)
   * @param {Object} entitySchema - the schema for the entity the request is
   *                                for. (required)
   * @param {Object} requestObj - an object that contains all of the possible
   *                              parts of the request (payload, uriPathVars,
   *                              uriQuery, uriOptions and addlHeaders
   *                              (optional). Can be a stringified Object.
   * @param {Boolean} translate - whether to translate the response. Defaults
   *                              to true. If no translation will just return
   *                              "success" or an error message
   * @param {Function} callback - a callback function to return the result of the request
   */
  genericRestRequest(entity, action, entitySchema, requestObj, translate, callback) {
    const origin = `${this.myid}-restHandler-genericRestRequest`;
    log.trace(`${origin}: ${entity}-${action}`);

    try {
      // verify parameters passed are valid
      if (!entity) {
        const errorObj = this.transUtil.formatErrorObject(origin, 'Missing Data', ['Entity'], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }
      if (!action) {
        const errorObj = this.transUtil.formatErrorObject(origin, 'Missing Data', ['Action'], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }
      if (!entitySchema) {
        const errorObj = this.transUtil.formatErrorObject(origin, 'Missing Data', ['Entity Schema'], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }

      // verify path for call
      if (!entitySchema.entitypath) {
        const errorObj = this.transUtil.formatErrorObject(origin, 'Invalid Action File', ['missing entity path', `${entity}/${action}`], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }

      // verify method for call
      if (!entitySchema.method) {
        const errorObj = this.transUtil.formatErrorObject(origin, 'Invalid Action File', ['missing method', `${entity}/${action}`], null, null, null);
        log.error(errorObj.IAPerror.displayString);
        return callback(null, errorObj);
      }

      // set the translate flag - defaults to true
      let translateFlag = true;
      if (typeof translate === 'boolean') {
        translateFlag = translate;
      }

      // get the path from the entity schema
      let uriPath = entitySchema.entitypath;
      const callMeth = entitySchema.method;
      let respType = 'default';

      // break out the variables in the requestObj
      let payload = null;
      let uriPathVars = null;
      let uriQuery = null;
      let uriOptions = null;
      let addlHeaders = null;
      let authData = null;

      if (requestObj !== null) {
        if (requestObj.payload) {
          ({ payload } = requestObj);
        }
        if (requestObj.uriPathVars) {
          ({ uriPathVars } = requestObj);
        }
        if (requestObj.uriQuery) {
          ({ uriQuery } = requestObj);
        }
        if (requestObj.uriOptions) {
          ({ uriOptions } = requestObj);
        }
        if (requestObj.addlHeaders) {
          ({ addlHeaders } = requestObj);
        }
        if (requestObj.authData) {
          ({ authData } = requestObj);
        }
      }

      // build the request path from the information provided
      const result = buildRequestPath(entity, action, entitySchema, uriPath, uriPathVars, uriQuery, uriOptions);

      // reset the local variables
      uriPath = result.path;
      respType = result.type;

      // merge the additional headers
      const thisAHdata = mergeHeaders(addlHeaders, entitySchema);

      // build the request path from the information provided
      const bodyString = buildPayload(entity, action, entitySchema, payload);

      if (callMeth !== 'GET' && bodyString !== '{}') {
        thisAHdata['Content-length'] = Buffer.byteLength(bodyString);
      }

      // set up the request to be sent
      const request = {
        method: callMeth,
        path: uriPath,
        addlHeaders: thisAHdata,
        respType,
        body: bodyString,
        origPath: entitySchema.entitypath
      };

      if (authData) {
        request.authData = authData;
      }

      // actual call for the request
      if (translateFlag && respType.indexOf('withpath') === 0) {
        return handleRestRequest(request, uriPathVars[0], entitySchema, callback);
      }
      if (translateFlag) {
        return handleRestRequest(request, 'map', entitySchema, callback);
      }

      return handleRestRequest(request, 'nomap', entitySchema, callback);
    } catch (e) {
      // handle any exception
      const errorObj = this.transUtil.checkAndReturn(e, origin, 'Issue during generic request');
      return callback(null, errorObj);
    }
  }

  /**
   * @summary Formats and makes the healthcheck call
   *
   * @function healthcheckRest
   * @param {Object} healthSchema - the schema for the healthcheck (optional)
   * @param {Object} requestObj - an object that contains all of the possible
   *                              parts of the request (payload, uriPathVars,
   *                              uriQuery, uriOptions and addlHeaders
   *                              (optional). Can be a stringified Object.
   * @param {Function} callback - a callback function to return the result of the healthcheck
   */
  healthcheckRest(healthSchema, requestObj, callback) {
    const origin = `${this.myid}-restHandler-healthcheckRest`;
    log.trace(origin);

    try {
      // break out the variables in the requestObj
      let payload = null;
      let uriPathVars = null;
      let uriQuery = null;
      let uriOptions = null;
      let addlHeaders = {};
      let authData = null;

      if (requestObj !== null) {
        if (requestObj.payload) {
          ({ payload } = requestObj);
        }
        if (requestObj.uriPathVars) {
          ({ uriPathVars } = requestObj);
        }
        if (requestObj.uriQuery) {
          ({ uriQuery } = requestObj);
        }
        if (requestObj.uriOptions) {
          ({ uriOptions } = requestObj);
        }
        if (requestObj.addlHeaders) {
          ({ addlHeaders } = requestObj);
        }
        if (requestObj.authData) {
          ({ authData } = requestObj);
        }
      }

      if (healthSchema) {
        // verify path for call
        if (!healthSchema.entitypath) {
          const errorObj = this.transUtil.formatErrorObject(origin, 'Invalid Action File', ['missing entity path', '.system/healthcheck'], null, null, null);
          log.error(errorObj.IAPerror.displayString);
          return callback(null, errorObj);
        }

        // verify method for call
        if (!healthSchema.method) {
          const errorObj = this.transUtil.formatErrorObject(origin, 'Invalid Action File', ['missing method', '.system/healthcheck'], null, null, null);
          log.error(errorObj.IAPerror.displayString);
          return callback(null, errorObj);
        }

        // get the path from the entity schema
        let uriPath = healthSchema.entitypath;
        const callMeth = healthSchema.method;
        let respType = 'default';

        // build the request path from the information provided
        const result = buildRequestPath('.system', 'healthcheck', healthSchema, uriPath, uriPathVars, uriQuery, uriOptions);

        // reset the local variables
        uriPath = result.path;
        respType = result.type;

        // merge the additional headers
        const thisAHdata = mergeHeaders(addlHeaders, healthSchema);

        // build the request path from the information provided
        const bodyString = buildPayload('.system', 'healthcheck', healthSchema, payload);

        if (callMeth !== 'GET' && bodyString !== '{}') {
          thisAHdata['Content-length'] = Buffer.byteLength(bodyString);
        }

        // set up the request to be sent
        const request = {
          method: callMeth,
          path: uriPath,
          addlHeaders: thisAHdata,
          respType,
          body: bodyString,
          origPath: healthSchema.entitypath
        };

        if (authData) {
          request.authData = authData;
        }

        // actual call for the request
        return handleRestRequest(request, 'nomap', healthSchema, callback);
      }

      // call to run healthcheck - if using properties
      return this.connector.healthCheck(healthSchema, null, addlHeaders, callback);
    } catch (e) {
      // handle any exception
      const errorObj = this.transUtil.checkAndReturn(e, origin, 'Issue during healthcheck request');
      return callback(null, errorObj);
    }
  }

  /**
   * getQueue is used to get information for all of the requests currently in the queue.
   *
   * @function getQueue
   * @param {Function} callback - a callback function to return the queue
   */
  getQueue(callback) {
    const origin = `${this.myid}-restHandler-getQueue`;
    log.trace(origin);

    try {
      return this.connector.getQueue(callback);
    } catch (e) {
      // handle any exception
      const errorObj = this.transUtil.checkAndReturn(e, origin, 'Issue getting queue');
      return callback(null, errorObj);
    }
  }
}

module.exports = RestHandler;
